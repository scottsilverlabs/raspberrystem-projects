<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<meta http-equiv="CONTENT-TYPE" content="text/html; charset=utf-8"><title>USING BUTTONS WITH GPIO</title>

<link rel="stylesheet" type="text/css" href="default.css">
<link type="text/css" rel="stylesheet" href="/assets/cmirror/codemirror.css">
<link type="text/css" id="theme" rel="stylesheet" href="/assets/themes/solarized-dark.css">
<script type="text/javascript" src="/assets/cmirror/codemirror.js"></script>
<script type="text/javascript" src="/assets/cmirror/python.js"></script>
<script type="text/javascript" src="codeblocks.js"></script>
</head>
<body style="direction: ltr; color: rgb(0, 0, 10);" lang="en-US" link="#0563c1">
<header>
    <div id=title>USING BUTTONS WITH GPIO</div>
    <div id=description>In this project, we will use GPIOs to get input from a pushbutton
    into our software.</div>
    <div id=hw_required>I/O (Input/Output) RaspberrySTEM Cell</div>
    <div id=concepts_required><a href="STRING_THEORY.html">STRING THEORY</a><br><a href="CALCULATIONS.html">CALCULATIONS</a></div>
    <div id=troubleshooting><a href="TROUBLESHOOTING.html">Having issues?  Check out the Troubleshooting Guide.</a></div>
</header>

<p>In the previous project, we saw how GPIOs can be used as outputs to control
components attached to the Raspberry Pi (like our LED). GPIOs can also be
used as inputs to take information from external components; that
input can then be acted upon by the Raspberry Pi and appropriate
actions can be taken.</p>

<h2>GPIOs as Inputs</h2>
<p>Much like GPIO
outputs work by simply setting a voltage on the GPIO pin to either 0V
or 3.3V, GPIO inputs work by reading the voltage – either 0V or
3.3V – being sent to the GPIO pin.</p>
<p>For example, a GPIO
can be used to get the current&nbsp;state of a button or switch
(pressed or released). &nbsp;Based on the current state, the
software can do what we expect when the button/switch is in that state. &nbsp;</p>
<br>
<div class="info">
<div>"State"</div>
<div>
<p>"State" is a common term using in electronics and just means
the current condition or situation of a component or circuit.<br>
<br>
For
example, in the case of a button or switch, state would refer to
whether the button is currently being pressed or released.
&nbsp;For
an LED, state might refer to whether the LED was illuminated or not.</p>
</div>
</div>
<br>
<p class="MsoNormal">In the <a href="INTRODUCING_BUTTONS.html">INTRODUCING BUTTONS</a> 
project, we inserted a button into the circuit to act as a physical switch -- when pressed, 
the circuit was completed and when released, the circuit was open. No software was required.</p>
<p class="MsoNormal"> But if we write software that interacts with our hardware
(by reading the state of the button through a GPIO) we add a world of possibilites. 
For example,
perhaps you want to count how many times a button is pressed in a
certain time
period, and take different actions based on that number?<span style="">&nbsp; </span>Or perhaps you want to
time how long a button
is pressed and take action based on the length of the press?<span style="">&nbsp; </span>Or maybe a button press
needs to trigger an
action in another circuit that the button isn’t attached to?</p>
<p class="MsoNormal">To perform more complicated
operations like these, instead
of wiring the button directly into the circuit, we can wire the
button
as an input to a GPIO.<span style="">&nbsp; </span>As
we discussed
earlier, GPIOs can be used as inputs to take information from external
components (like buttons); that input can then be acted upon by the
Raspberry
Pi.</p>
<p class="MsoNormal">GPIO inputs work by reading the
voltage at the GPIO pin – either 0V (“low”) or 3.3V (“high”).</p>
<p class="MsoNormal">For example, a GPIO can be used to
get information from a
button or switch.<span style="">&nbsp; </span>In
the circuit design we use and will explain below, when a button is left
unpressed, the voltage at the
GPIO pin is
“high” (3.3V); when the button is pressed, the voltage at the GPIO pin
will go
“low” (switch to 0V).<span style="">&nbsp; </span>The
GPIO will
register the voltage, and the Raspberry Pi can then take action on
either a
pressed or released button.</p>
<p class="MsoNormal">To wire a button to a GPIO, this is
what the circuit schematic would
look like:</p>
<div style="text-align: center;"><span style="font-family: &quot;Verdana&quot;,serif;"><span
style="font-style: italic;"><img class=schematic style="max-width:600px;" src="img/Pushbutton-to-GPIO.png"></span></span><br>
</div>
<p class="MsoNormal"></p>

<h2>Reading Buttons Using GPIOs</h2>
<p class="MsoNormal">To implement what we discuss above as an actual breadboard circuit is 
easy.  First, we start with an empty breadboard, with power and ground wired from the 
Lid Connector Board, like this:
<br>
<center><img class="bb" src="img/Just_Power_bb.png"></center>
<br>

With our breadboard empty, here is how we build our circuit and then use code to get input 
from the button through the GPIO:</p>
<br>
<p style="font-weight: bold;">Step
#1: &nbsp;Pl<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;"></span>ace
button on breadboard.</p>
<p class="MsoNormal">
We start by placing a button on
the breadboard.  Remember, it is important that the button is oriented correctly -- the two independent sides of the button
must sit
on different connect strips, as follows:</p>
<br>
<table style="margin: auto; width: 70%;">
<tbody>
<tr>
<td><img src="img/Button_orientation_correct.png" width="285"></td>
<td><img src="img/Button_orientation_wrong.png" width="285"></td>
</tr>
<tr>
<td><b>CORRECT</b></td>
<td><b><span style="color: red;">WRONG!!!</span></b></td>
</tr>
</tbody>
</table>
<br>
<p style="text-indent: -0.25in;"><b style=""><span style=""><span style="">2.<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;
<br>
</span></span></span></b><b style="">Step
#2: &nbsp;Wire one side of the button to a GPIO.</b></p>
<p class="MsoNormal">Next, we connect one side of the
button (it doesn’t matter which one, as the internal components of the
button
are symmetrical) to a GPIO.<span style="">&nbsp; </span>In
this
example, we’ll connect the button to GPIO14.</p>
<br>
<img class="bb" src="img/Buttons_with_GPIO_1_bb.png">
<br>
<p><span style="font-weight: bold;">Step #3:
&nbsp;Wire the other side of the button to
ground.</span></p>
<p class="MsoNormal">Finally, we connect the other side
of the button to ground.
</p>
<br>
<img class="bb" src="img/Buttons_with_GPIO_2_bb.png">
<p class="MsoNormal">That’s it for the wiring – pretty
simple, right?</p>
<br>
<p><span style="font-weight: bold;">Step #4: Write the code.
</span></p>
<p class="MsoNormal">Now that the circuit is wired, we can
write the code to get
the GPIO state (low or high):</p>
<br>
<div class="code" data-firstline="1">
<div></div>
<textarea>
from rstem.button import Button
my_button = Button(14)
print(my_button.is_pressed())
</textarea></div>
<br>
<p class="MsoNormal">In this most basic example, we are
reading the GPIO a single
time (the moment the program is run) and we are printing the state of
the
button at that moment.<span style="">&nbsp; </span>Try
running the
program a couple times, either holding down or not holding down the
button at
the moment the program is run.</p>
<p>You may notice that this example is similar to the 
<a href="GENERAL_PURPOSE_INPUT-OUTPUT.html">GENERAL PURPOSE INPUT OUTPUT</a>
example.  But in this case, we configure the GPIO as a button instead of an
output:
</p>
<ul>
<li> <p>In Line 2: We're configuring GPIO 14 as a button.</p> </li>
<li> <p>In Line 3: We're getting the state of the button, and printing it.</p> </li>
</ul>
<p>
We'll look at these concepts again in more detail in upcoming projects.
</p>
<p class="MsoNormal">To make the program a little more
interesting (and
convenient!), we can insert a loop so that, instead of just reading the
state
of the GPIO one time, we can continually read and print the state of
the GPIO
for as long as the program is running.<span style="">&nbsp;
</span></p>
<p class="MsoNormal">Here’s what that code would look like:</p>
<br>
<div class="code" data-firstline="1">
<div></div>
<textarea>
from rstem.button import Button
import time

my_button = Button(14)

while True: 
	my_button = Button(14) 
	print(my_button.is_pressed())
	time.sleep(0.1)
</textarea></div>
<br>
<p class="MsoNormal">Run this program and then alternate
between pressing and not
pressing the button.<span style="">&nbsp; </span>Take
a look at the
output window – you should see an indication of when the button is
pressed and
when it is released.</p>
<br>
<div class="info">
<div>"while True:"</div>
<div>
<p>
You may have noticed that we used a new programming concept above:</p>
<pre>while True:</pre>
<p>We'll discuss exactly how this works in a future project, but for now, just know
that using this line of code will force the block of code below it to be repeated over 
and over, forever.
</p>
</div>
</div>
<br>
<p>When you're done testing your button, you can stop the program by pressing the
square STOP icon in the upper-left-hand corner of the code window (this icon replaced the PLAY
icon while the program was running).
</p>
<p class=nextprev><a href="index.html">home</a> | 
<a href="GENERAL_PURPOSE_INPUT-OUTPUT.html">prev</a> |
<a href="FLASHLIGHT.html">next</a></p>
</body></html>
