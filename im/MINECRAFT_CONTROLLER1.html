<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
    <meta http-equiv="CONTENT-TYPE" content="text/html; charset=utf-8">
    <link rel="stylesheet" type="text/css" href="default.css">
    <link type="text/css" rel="stylesheet" href="/assets/cmirror/codemirror.css">
    <link type="text/css" id="theme" rel="stylesheet" href="/assets/themes/solarized-dark.css">
    <script type="text/javascript" src="/assets/cmirror/codemirror.js"></script>
    <script type="text/javascript" src="/assets/cmirror/python.js"></script>
    <script type="text/javascript" src="onload.js"></script>
    <script type="text/javascript" src="codeblocks.js"></script>
    <script type="text/javascript" src="toc_order.js"></script>
    <script type="text/javascript" src="project.js"></script>
</head>
<body>
<header>
    <div id=title></div>
    <div id=description>This is a minecraft project</div>
    <div id=hw_required>
    Accelerometer Cell<br>
    LED Matrix Cell
    </div>
    <div id=troubleshooting><a href="TROUBLESHOOTING.html">Having issues?  Check out the Troubleshooting Guide.</a></div>
</header>
<h2>Overview</h2>
<p>In this project, we will use the RaspberrySTEM kit to create a Minecraft controller.  This first version of the controller will 
use the accelerometer to control where your character, Steve, is looking.  In addition, we'll use four buttons to control
Steve's movement foreward, backwards, left and right. 

<h2>Hardware Setup</h2>
<p>The hardware setup for this project includes the accelerometer and four buttons.  For more information about setting up
the accelerometer, refer back to the "Accelerometer" project.  For more information about setting up the buttons, refer
back to the "Button" project.

<p>In the code we write below, we will assume that the buttons are attached the following GPIOs:

<ul>
<li><p>Top Button:  GPIO15</li>
<li><p>Right Button:  GPIO14</li>
<li><p>Button Button:  GPIO23</li>
<li><p>Left Button:  GPIO18</li>
</ul>

<p>This is what your hardware setup should look like:</p>

<img class="bb" src="img/Minecraft_Accel_4way_1button_bb.png">

<h2>Writing Our Code</h2>

<p>Our code for this project -- and most of our Minecraft projects -- will 
consist of three parts:

<ol>
<li><p>Initialization Code</li>
<li><p>Starting Minecraft</li>
<li><p>The Game Loop</li>
</ol>

<h3>Step #1:  Initialization Code</h3>

<p>Our initialization code will first import the modules and functions we'll
need in the project.  For this project, we need to import the functions needed
for the following:
</p> 

<ul>
<li><p>Using the Accelerometer</li>
<li><p>Using the Buttons</li>
<li><p>Starting Minecraft</li>
<li><p>Implementing the <code>sleep</code> function</li>
</ul>

<p>
Here is what the import function code will look like:
</p> 

<div class="code" data-firstline="0"> <div></div> <textarea>
from rstem.accel import Accel
from rstem.button import Button
from rstem.mcpi import control
import time
</textarea></div>

<p>
Next, we'll create our buttons and our accelerometer objects:
</p> 

<div class="code" data-firstline="0"> <div></div> <textarea>
left = Button(18)
right = Button(14)
up = Button(15)
down = Button(23)
smash = Button(7)
jump = Button(24)

accel = Accel()
</textarea></div>

<h3>Step #2:  Start Minecraft</h3>

<p>
Once we have our initialization code written, we can bring up the
Minecraft window.  As we discussed in an earlier project, that is
accomplished using the <code>control.show()</code> function:
</p> 

<div class="code" data-firstline="0"> <div></div> <textarea>
control.show()
</textarea></div>

<h3>Step #3:  The Game Loop</h3>

<p>
Finally, we'll create the game loop that will house the logic for
our code.  For this project, our game loop will continue forever
(until the user manually stops the game), so our loop will start
with:
</p> 

<div class="code" data-firstline="0"> <div></div> <textarea>
while True:
</textarea></div>

<p>
Each time through the loop, we'll want to do two things:
</p>

<ol>
<li><p>Check for button presses and take appropriate action</li>
<li><p>Check the accelerometer movement and take appropriate action</li>
</ol>

<p>
We'll start by checking each of the four buttons for presses, and if
one of the buttons is pressed, we will move Steve in that direction.
Here is what that code will look like:
</p>

<div class="code" data-firstline="0"> <div></div> <textarea>
if left.is_pressed():
    control.left()
else:
    control.left(release=True)
if right.is_pressed():
    control.right()
else:
    control.right(release=True)
if up.is_pressed():
   control.forward()
else:
    control.forward(release=True)
if down.is_pressed():
    control.backward()
else:
    control.backward(release=True)
if smash.is_pressed():
    control.smash()
else:
    control.smash(release=True)
if jump.is_pressed():
    control.jump()
else:
    control.jump(release=True)
</textarea></div>

<p>
If a key press is indicated, the code will start movement in that direction
using the <code>control</code> function; if a key press is not indicated, 
movement in that direction will be stopped using <code>release=True</code> in our 
control statements.
</p>  

<p>
Next, we'll read the position of the kit using the data from the accelerometer
and we'll control where Steve is looking based on that information:
</p> 

<div class="code" data-firstline="0"> <div></div> <textarea>
x, y, z = accel.forces()
control.look(up=50*y, left=50*x)
</textarea></div>

<p>
Notice that because the the accelerometer returns a value between -1 and 1,
and because our API expects a value between -50 and 50, we have to multiply
our accelerometer result by 50 in our code.
</p> 

<p>
Finally, to keep our game loop from running too quickly, we'll implement a brief
<code>sleep</code> (1/100 of the second) at the bottom of the loop:
</p> 

<div class="code" data-firstline="0"> <div></div> <textarea>
time.sleep(0.01)
</textarea></div>


<h3>Full Code</h3>

<p>
Here is what the full code for this project should look like:
</p>

<div class="code" data-firstline="1"> <div></div> <textarea>
from rstem.accel import Accel
from rstem.button import Button
from rstem.mcpi import control
import time

left = Button(18)
right = Button(14)
up = Button(15)
down = Button(23)

accel = Accel()

control.show()

while True:
    if left.is_pressed():
        control.left()
    else:
        control.left(release=True)
    if right.is_pressed():
        control.right()
    else:
        control.right(release=True)
    if up.is_pressed():
        control.forward()
    else:
        control.forward(release=True)
    if down.is_pressed():
        control.backward()
    else:
        control.backward(release=True)
    if smash.is_pressed():
        control.smash()
    else:
        control.smash(release=True)
    if jump.is_pressed():
        control.jump()
    else:
        control.jump(release=True)
	
    x, y, z = accel.forces()
    control.look(up=50*y, left=50*x)
    
    time.sleep(0.01)

</textarea></div>

<h2>Additional Challenges</h2>
<p>
<p>
Here are some additional challenges you can attempt on your own:
</p>

<ol>
<li><p>Modify the code so that pressing and holding a button doesn't work -- Steve 
only moves a small amount each time a button is pressed</li>
<li><p>Modify the code so that Steve's movements are based on the accelerometer
and where he looks are controlled by the buttons.</li>
<li><p>Add another button (or remap an existing button) to allow Steve to
crouch at the press of the button.</li>
<ol>

<div id=footer></div>
</body></html>
